<p>&lt;!DOCTYPE html&gt;
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge"></p>

<pre><code>&lt;!-- CSS styles --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;

&lt;!-- D3 --&gt;
&lt;script defer src=&quot;https://d3js.org/d3.v5.min.js&quot;&gt;&lt;/script&gt;

&lt;!-- JQuery --&gt;
&lt;script defer src=&quot;https://code.jquery.com/jquery-3.4.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;!-- Perceptron code --&gt;
&lt;script defer src=&quot;dist/main.js&quot;&gt;&lt;/script&gt;

&lt;!-- KaTEX stuff --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css&quot; integrity=&quot;sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/p&gt;
&lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js&quot; integrity=&quot;sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
&lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js&quot; integrity=&quot;sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI&quot; crossorigin=&quot;anonymous&quot;
  onload=&quot;renderMathInElement(document.body);&quot;&gt;&lt;/script&gt;
&lt;title&gt;Perceptrons Explained&lt;/title&gt;
</code></pre>

<p></head>
<body></p>

<h1>Introduction</h1>

<p>The perceptron is a well-known machine linear classifier invented in 1958 by Frank Rosenblatt. In the binary classification case, the perceptron is parameterized by a weight vector \(w\) and outputs \(\hat{y_i} = \text{sign}(w \cdot x_i)\) depending on if the class is positive (\(+1\)) or negative (\(-1\)). What makes this model interesting is that <em>if</em> the data we are trying to classify are linearly seperable, then the perceptron learning algorithm will always converge to a set of weights \(w\) which will correctly classify all points.</p>

<p>The perceptron learning algorithm consists of 4 steps:</p>

<ol>
<li>Initialize a set of starting weights \(w_1 = [0...0]\).</li>
<li>Run the model on your dataset until you hit the first misclassified point.</li>
<li>If a point \((x_t, y_t)\) is misclassified, update the weight \(w_i\) with the following rule: \(w_{i+1} = w_i + y_t(x_t)^T\). In other words, we add (or subtract) the misclassified point&#39;s value to (or from) our weights.</li>
<li>Go back to step 2 until all points are classified correctly.</li>
</ol>

<p>To get a feel for what I mean, try out the interactive demo below.</p>

<p>Clicking Generate Points will pick a random hyperplane (that goes through 0, for simplicity) to be the ground truth. Then, points are randomly generated on both sides of the hyperplane with respective +1 or -1 labels. </p>

<p>After that, you can click Fit Perceptron to fit the model for the data. You can see each misclassified point flash briefly, moving the perceptron&#39;s weights either up or down, respectively throughout the training procedure.</p>

<p><div class="graph">
    <div id="scatterplot0"></div>
    <div class="input-holder">
      <input type="range" class="numPoints slider" min="10" max="200" value="50"> <span class="input-value"></span><span>&nbsp; points</span>
    </div>
    <br>
    <div>
      <span class="trueSlope">True slope:</span>
      <br>
      <span class="predSlope">Learned slope:</span>
    </div>
    <br>
    <button id="generate0">Generate Data</button>
    <button id="fit0">Fit Perceptron</button>
  </div></p>

<h1>Convergence Proof</h1>

<p>While the above demo gives some good visual evidence that \(w\) always converges to a line which separates our points, there is also a formal proof that adds some useful insights. For the proof, we&#39;ll consider running our algorithm for \(k\) iterations and then show that \(k\) is upper bounded by a finite value, meaning our algorithm will always return a good \(w\) in finite time.</p>

<p>Before we begin, let&#39;s make our assumptions clear:</p>

<ol>
<li>There exists some optimal \(w^*\)  such that for some \(\epsilon &gt; 0\), \(y_i(w^* \cdot x_i) \ge \epsilon\) for all inputs on the training set. In other words, we assume the points are linearly separable with a margin of \(\epsilon\) (as long as our hyperplane is normalized). </li>
<li>\(||w^*|| = 1\). Though not strictly necessary, this gives us a unique \(w^*\) and makes the proof simpler.</li>
<li>For all \(x_i\) in our dataset \(X\), \(||x_i|| &lt; R\). In other words, this bounds the coordinates of our points.</li>
</ol>

<h3>Inequality 1</h3>

<p>First, let \(w^{k+1}​\) be the set of weights returned by our algorithm after running it for \(k+1​\) iterations.</p>

<p>We&#39;ll start by showing that:</p>

<p>\(w_{k+1} \cdot (w^*)^T \ge w_k \cdot (w^*)^T + \epsilon\)</p>

<p>By definition, if we assume that \(w_{k}\) misclassified \((x_t, y_t)\), we update \(w_{k+1} = w_k + y_t(x_t)^T \)</p>

<p>Thus:</p>

<p>\(w_{k+1}\cdot (w^*)^T = (w_k + y_t(x_t)^T)\cdot (w^*)^T\) </p>

<p>Next, multiplying out the right hand side, we get:</p>

<p>\(w_{k+1}\cdot (w^*)^T = w_k \cdot (w^*)^T + y_t(w^* \cdot x_t)\)</p>

<p>By assumption 1, we get, as desired:</p>

<p>\(w_{k+1}\cdot (w^*)^T \ge w_k \cdot (w^*)^T + \epsilon\) </p>

<p>Next, we&#39;ll prove by induction that:</p>

<p>\(w^{k+1} \cdot (w^*)^T \ge k\epsilon \)</p>

<p>Base case where \(k = 0\):</p>

<p>\(w^{0+1} \cdot w^* = 0 \ge 0 * \epsilon = 0\)</p>

<p>Inductive step where \(k \to k+1\):</p>

<p>From what we proved above, we get:</p>

<p>\(w^{k+1} \cdot (w^*)^T \ge w_k \cdot (w^*)^T + \epsilon\)</p>

<p>Then, from the inductive hypothesis, we get:</p>

<p>\(w^{k+1} \cdot (w^*)^T \ge (k-1)\epsilon + \epsilon\)</p>

<p>Which gets us, as desired:</p>

<p>\(w^{k+1} \cdot (w^*)^T \ge k\epsilon\)</p>

<p>Next, we see that:</p>

<p>\(w^{k+1} \cdot (w^*)^T = ||w^{k+1}|| * ||w^*||*cos(w^{k+1}, w^*)\)</p>

<p>Because \(cos(x) \le 1\), we see that:</p>

<p>\(w^{k+1} \cdot (w^*)^T \le ||w^{k+1}||*||w^*||\)</p>

<p>Then, because \(||w^*|| = 1\) by assumption 2, we have that:</p>

<p>\(||w^{k+1}|| \ge k\epsilon\)</p>

<p>Because all values on both sides are positive, we also get:</p>

<p>\(||w^{k+1}||^2 \ge k^2\epsilon^2\)</p>

<h3>Inequality 2</h3>

<p>First, we notice that:</p>

<p>\(||w_{k+1}||^2 = ||w_{k} + y_t (x_t)^T||^2\)</p>

<p>Multiplying this out, we get:</p>

<p>\(||w_{k+1}||^2 = ||w_k||^2 + 2y_t (w_k \cdot x_t) + ||x_k||^2\)</p>

<p>Then, because we updated on point \((x_t, y_t)\), we know that it was classified incorrectly. Thus, \(2y_t(w_k \cdot x_t) &lt; 0\).</p>

<p>Thus:</p>

<p>\(||w_{k+1}||^2 \le ||w_k||^2 + ||x_k||^2\)</p>

<p>Then, by assumption 3, we know that:</p>

<p>\(R \ge ||x_k||\)</p>

<p>Thus:</p>

<p>\(||w_{k+1}||^2 \le ||w_k||^2 + R^2\)</p>

<p>Now, we&#39;ll prove by induction that:</p>

<p>\(||w_{k+1}||^2 \le kR^2\)</p>

<p>Base case, where \(k=0\):</p>

<p>\(||w_{0+1}||^2  = 0 \le 0*R^2 = 0\)</p>

<p>Inductive step, where \(k \to k+1\):</p>

<p>From what we proved above:</p>

<p>\(||w_{k+1}||^2 \le ||w_k||^2 + R^2 \)</p>

<p>Then, by the inductive hypothesis:</p>

<p>\(||w_{k+1}||^2 \le (k-1)R^2 + R^2\)</p>

<p>Which gets us, as desired:</p>

<p>\(||w_{k+1}||^2 \le kR^2\)</p>

<h3>Putting It Together</h3>

<p>From Inequalities 1 and 2, we get:</p>

<p>\(k^2\epsilon^2 \le ||w_{k+1}||^2 \le kR^2\)</p>

<p>Dividing out, we get:</p>

<p>\(k \le \frac{R^2}{\epsilon^2}\)</p>

<p>Thus, we see that our algorithm will run for no more than \(\frac{R^2}{\epsilon^2}\) iterations. </p>

<h3>Changing the Margin</h3>

<p>It&#39;s interesting to note that our convergence proof does not explicity depend on the dimensionality of our data points. Rather, the runtime depends on the size of the margin between the closest point and the separating hyperplane. </p>

<p>In other words, the difficulty of the problem is bounded by how easily separable the two classes are. The larger the margin, the faster the perceptron should converge. Below, you can try adjusting the margin between the two classes to see how increasing or decreasing it changes how fast the perceptron converges.</p>

<p><div class="graph">
    <div id="scatterplot1"></div>
    <div class="input-holder">
      <input type="range" class="numPoints slider" min="10" max="200" value="50"> <span class="input-value"></span><span>&nbsp; points</span>
    </div>
    <div class="input-holder">
      <input class="margin slider" type="range" min="0" max="50" value="10"><span class="input-value"></span><span>% margin</span>
    </div>
    <br>
    <div>
      <span class="trueSlope">True slope:</span>
      <br>
      <span class="predSlope">Learned slope:</span>
    </div>
    <br>
    <button id="generate1">Generate Data</button>
    <button id="fit1">Fit Perceptron</button>
  </div></p>

<h1>Linearly Unseparable Data</h1>

<p>In the real world, data is never clean; it&#39;s noisy, and the linear separability assumption we made is basically never achieved. But, as we saw above, the size of the margin that separates the two classes is what allows the perceptron to converge at all. So the normal perceptron learning algorithm gives us no guarantees on how good it will perform on noisy data. </p>

<p>However, there are several modifications to the perceptron algorithm which enable it to do relatively well, even when the data is not linearly separable. Below, we&#39;ll explore the Maxover algorithm and the Voted Perceptron.</p>

<h1>Maxover Algorithm</h1>

<p>If the data are not linearly separable, it would be good if we could at least converge to a locally good solution. In 1995, Andreas Wendemuth introduced three modifications to the perceptron in <a href="docs/learning_the_unlearnable.pdf">Learning the Unlearnable</a>, all of which allow the algorithm to converge, even when the data is not linearly separable. </p>

<p>The main change is to the update rule. Instead of \(w_{i+1} = w_i + y_t(x_t)^T\), the update rule is changed to \(w_{i+1} = w_i + C(w_i, x^*)\cdot w_i + y^*(x^*)^T\), where \((x^*, y^*)\) refers to a specific data point (to be defined later) and \(C\) is a function of this point as well as the previous iteration&#39;s weights.</p>

<p>In this way, Wendemuth goes on to show that as long as \((x^*, y^*)\) and \(C\) are chosen to satisfy certain inequalities, this update rule will eventually converge. </p>

<p>(See the paper for more details because I&#39;m also a little unclear on <em>exactly</em> how the math works out, but the main intuition is that as long as \(C(w_i, x^*)\cdot w_i + y^*(x^*)^T\) has both a bounded norm and a positive dot product with repect to \(w_i\), then norm of \(w\) will always increase with each update. Then, in the limit, as the norm of \(w\) grows, future updates (because they always add a bounded value) will not shift its direction very much, and it will eventually converge.)</p>

<p>Each one of the modifications uses a different selection criteria for selecting \((x^*, y^*)\). One of the three algorithms in Wendemuth&#39;s paper uses the criteria where \((x^*, y^*)_t\) is defined to be a random point which satisfies the following inequality:</p>

<p>\(\frac{y^*(w_t \cdot x^*)}{||w_t||} &lt; k\) </p>

<p>This is the version you can play with below. Note the value of \(k\) is a tweakable hyperparameter; I&#39;ve merely set it to default to -0.25 below because that&#39;s what worked well for me when I was playing around. The error rate is also displayed once the perceptron is done training. Given a noise proportion of \(p\), we&#39;d ideally like to get an error rate as close to \(p\) as possible. We&#39;d also ideally like to get a separating hyperplane that is close to the original one, and note that minimizing the error on noisy samples does not automatically achieve this goal.</p>

<p><div class = "graph">
    <div id="scatterplot2"></div>
    <div class="input-holder">
      <input type="range" class="numPoints slider" min="10" max="200" value="50"> <span class="input-value"></span><span>&nbsp; points</span>
    </div>
    <div class="input-holder">
      <input type="range" class="noise slider" min="0" max="40" value="10"> <span class="input-value"></span><span> % noise</span>
    </div>
    <div class="input-holder">
      <input type="range" class="k slider" min="-1" max="1" value="-0.25" step=".05"><span class="input-value"></span><span>&nbsp; (k)</span>
    </div>
    <br>
    <div>
      <span class="trueSlope">True slope:</span>
      <br>
      <span class="predSlope">Learned slope:</span>
    </div>
    <br>
    <button id="generate2">Generate Data</button>
    <button id="fit2">Fit Perceptron</button>
  </div>  </p>

<h1>Voted Perceptron</h1>

<p>Alternatively, if the data are not linearly separable, perhaps we could get better performance using an ensemble of linear classifiers. This is what Yoav Freund and Robert Schapire accomplish in 1999&#39;s <a href="docs/voted_perceptron.pdf">Large Margin Classification Using the Perceptron Algorithm</a>. (If you are familiar with their other work on boosting, their ensemble algorithm here is unsurprising.)</p>

<p>There are two main changes to the perceptron algorithm. The first is that, during each iteration when we update our weights \(w_t\), we store it in a list \(W\), along with a vote value \(c_t\), which represents how many data points \(w_t\) classified correctly before it got something wrong (and thus had to be updated). Then, at test time, our prediction for a data point \(x_i\) is the majority vote of all the weights in our list, weighted by their vote. </p>

<p>In other words, \(\hat{y_i} = \text{sign}(\sum_{w_j \in W} c_j(w \cdot x_i))\)</p>

<p>Though it&#39;s both intuitive and easy to implement, the analyses for the Voted Perceptron do not extend past running it just once through the training set. However, we empirically see that performance continues to improve if we make multiple passes through the training set and thus extend the length of \(W\). </p>

<p>Below, you can see this for yourself by changing the number of iterations the Voted Perceptron runs for, and then seeing the resulting error rate. During the training animation, each weight in \(W\) is displayed, with an intensity proportional to its vote. You can also hover a specific hyperplane to see the number of votes it got. Typically, the points with high vote are the ones which are close to the original line, which makes sense if the noise was zero-centered; we&#39;d expect something close to the original separating hyperplane to get most of the points correct.</p>

<p>Though at first this algorithm seems much more space-hungry than the either typical perceptron algorithm or the Maxover Perceptron, </p>

<p><div class = "graph">
    <div id="scatterplot3"></div></p>

<pre><code>&lt;div class=&quot;input-holder&quot;&gt;
  &lt;input type=&quot;range&quot; class=&quot;numPoints slider&quot; min=&quot;10&quot; max=&quot;200&quot; value=&quot;50&quot;&gt; &lt;span class=&quot;input-value&quot;&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp; points&lt;/span&gt;
&lt;/div&gt;
&lt;div class=&quot;input-holder&quot;&gt;
  &lt;input type=&quot;range&quot; class=&quot;noise slider&quot; min=&quot;0&quot; max=&quot;40&quot; value=&quot;10&quot;&gt; &lt;span class=&quot;input-value&quot;&gt;&lt;/span&gt;&lt;span&gt; % noise&lt;/span&gt;
&lt;/div&gt;
&lt;div class=&quot;input-holder&quot;&gt;
  &lt;input type=&quot;range&quot; class=&quot;iters slider&quot; min=&quot;1&quot; max=&quot;10&quot; value=&quot;5&quot;&gt; &lt;span class=&quot;input-value&quot;&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp; iterations&lt;/span&gt;
&lt;/div&gt;

&lt;br&gt;
&lt;div&gt;
  &lt;span class=&quot;trueSlope&quot;&gt;True slope:&lt;/span&gt;
  &lt;br&gt;
  &lt;span class=&quot;predSlope&quot;&gt;Learned slope:&lt;/span&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;button id=&quot;generate3&quot;&gt;Generate Data&lt;/button&gt;
&lt;button id=&quot;fit3&quot;&gt;Fit Perceptron&lt;/button&gt;
</code></pre>

<p></div>  </p>

<p></body>
</html></p>
